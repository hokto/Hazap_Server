import requests
import json
import urllib
import math

def Cal_Arclength(a,b,c,r):#余弦定理を用いて角度を出し、l=rθより弧の長さを求める
    if(a==0 or b==0):#実際のゴール-スタート間、もしくは最適ゴール-スタート間が0であれば角度が存在せず、孤の長さは0となる。
        return 0
    cosC=(a**2+b**2-c**2)/(2*a*b)#余弦定理
    if(cosC>1):#計算値なので多少超えることがあり、これを調整
        cosC=1
    elif(cosC<-1):
        cosC=-1
    radian=math.acos(cosC)#ラジアン角を求める
    arclength=r*radian#ラジアン角、半径を用いて孤の長さを計算
    return arclength
def Compare_route(start_pos,optimal_goal,real_goal):#ルート比較用関数
    if(math.isclose(optimal_goal.lat,real_goal.lat,abs_tol=0.0001,rel_tol=0.0001) and math.isclose(optimal_goal.lon,real_goal.lon,abs_tol=0.001,rel_tol=0.001)):#実際のゴール、最適なゴールの座標が同じであれば100%
        return 100.0
    real_dx=(real_goal.lon-start_pos.lon)#実際のルートにおける緯度、経度の変位を求め、傾きを計算 
    real_dy=(real_goal.lat-start_pos.lat)
    if(real_dx==0):#dxが0のとき、y軸に水平な直線に、dyが0のとき、x軸に水平な直線にする
        real_inclination=real_dy
    elif(real_dy==0):
        real_inclination=real_dx
    else:       
        real_inclination=real_dy/real_dx
    optimal_dx=(optimal_goal.lon-start_pos.lon)#実際のルートでも同様に傾きを計算
    optimal_dy=(optimal_goal.lat-start_pos.lat)
    if(optimal_dx==0):
        optimal_inclination=optimal_dy
    elif(optimal_dy==0):
        optimal_inclination=optimal_dx
    else:
        optimal_inclination=optimal_dy/optimal_dx
    radCandidate=[]#半径を求めるためにその候補となる値を格納するリスト
    if(real_dx!=0): 
        radCandidate.append(abs(real_dx))
    if(real_dy!=0):
        radCandidate.append(abs(real_dy))
    if(optimal_dx!=0):
        radCandidate.append(abs(optimal_dx))
    if(optimal_dy!=0):
        radCandidate.append(abs(optimal_dy))
    minr=min(radCandidate)#半径を求める
    totaldiff=0
    for i in range(100):
        r=(minr/100)*(i+1)#同心円の半径
        circumference=2*math.pi*r#円周
        if(real_dx==real_inclination):#x軸もしくはy軸に水平な直線の場合は、計算方法を変える。
            real_x=real_inclination
            real_y=real_inclination*r
        elif(real_dy==real_inclination):
            real_x=real_inclination*r
            real_y=real_inclination
        else:
            real_x=r/math.sqrt(real_inclination**2+1)#実際のゴール地点の傾きにおける各座標
            if(real_dx<0):
             real_x*=-1
            real_y=real_inclination*real_x
        if(optimal_dx==optimal_inclination):
            optimal_x=optimal_inclination
            optimal_y=optimal_inclination*r
        elif(optimal_dy==optimal_inclination):
            optimal_x=optimal_inclination*r
            optimal_y=optimal_inclination
        else:
            optimal_x=r/math.sqrt(real_inclination**2+1)#最適なゴール地点の傾きにおける各座標
            if(optimal_dx<0):
                optimal_x*=-1
            optimal_y=optimal_inclination*optimal_x
        realDistance=math.sqrt(real_x**2+real_y**2)#スタート-実際のゴール間の距離
        optimalDistance=math.sqrt(optimal_x**2+optimal_y**2)#スタート-最適なゴール間の距離
        OptimalRealdiff=math.sqrt((real_x-optimal_x)**2+(real_y-optimal_y)**2)#最適なゴール-実際のゴール間の距離
        arcLength=Cal_Arclength(realDistance,optimalDistance,OptimalRealdiff,r)#弧の長さ
        totaldiff+=50-(arcLength/circumference)*100#最大割合が50%
    return (totaldiff/100*2)#割合の平均値を返す
